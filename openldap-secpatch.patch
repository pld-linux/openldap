--- servers/slurpd/args.c	2002/08/16 10:56:35	1.1
+++ servers/slurpd/args.c	2002/08/26 13:42:24
@@ -109,15 +109,17 @@
 	    g->one_shot_mode = 1;
 	    break;
 	case 'r':	/* slapd replog file */
-	    strncpy( g->slapd_replogfile, optarg,
-			sizeof(g->slapd_replogfile)-1 );
-		g->slapd_replogfile[sizeof(g->slapd_replogfile)-1] = '\0';
+	    snprintf( g->slapd_replogfile, sizeof g->slapd_replogfile,
+		    "%s", optarg );
+
 	    rflag++;
 	    break;
-	case 't':	/* dir to use for our copies of replogs */
-	    g->slurpd_rdir = (char *)malloc (strlen(optarg) + strlen("/replica") + 1);
-	    sprintf(g->slurpd_rdir, "%s/replica", optarg);
-	    break;
+	case 't': {	/* dir to use for our copies of replogs */
+	    size_t sz;
+ 	    g->slurpd_rdir = (char *)malloc (sz = (strlen(optarg) + sizeof("/replica")));
+ 	    snprintf(g->slurpd_rdir, sz,
+ 			"%s" LDAP_DIRSEP "replica", optarg);
+ 	    } break;
 	default:
 	    usage( g->myname );
 	    return( -1 );
@@ -131,11 +133,13 @@
     }
 
     /* Set location/name of our private copy of the slapd replog file */
-    sprintf( g->slurpd_replogfile, "%s/%s", g->slurpd_rdir,
+    snprintf( g->slurpd_replogfile, sizeof g->slurpd_replogfile, 
+	    "%s" LDAP_DIRSEP "%s", g->slurpd_rdir, 
 	    DEFAULT_SLURPD_REPLOGFILE );
 
     /* Set location/name of the slurpd status file */
-    sprintf( g->slurpd_status_file, "%s/%s", g->slurpd_rdir,
+    snprintf( g->slurpd_status_file, sizeof g->slurpd_replogfile, 
+	    "%s" LDAP_DIRSEP "%s", g->slurpd_rdir, 
 	    DEFAULT_SLURPD_STATUS_FILE );
 
 	ber_set_option(NULL, LBER_OPT_DEBUG_LEVEL, &ldap_debug);
--- libraries/libldap/getfilter.c	2002/08/16 07:58:03	1.1
+++ libraries/libldap/getfilter.c	2002/10/15 10:37:51
@@ -338,8 +338,12 @@
 	f = filtbuf;
 
 	if ( prefix != NULL ) {
-	    strcpy( f, prefix );
-	    f += strlen( prefix );
+	    slen = snprintf(f, buflen, "%s",prefix);
+	    if( slen < 0 || slen >= buflen){
+		*filtbuf = '\0';
+		return;
+	    }
+	    f += slen;
 	}
 
 	for ( p = pattern; *p != '\0'; ++p ) {
@@ -370,8 +374,13 @@
 				    *f++ = ' ';
 				}
 				slen = strlen( valwords[ i ] );
-				AC_MEMCPY( f, valwords[ i ], slen );
-				f += slen;
+				if( (buflen > slen) && 
+					((f - filtbuf) < (buflen - slen)) ){
+				    AC_MEMCPY( f, valwords[ i ], slen );
+				    f += slen;
+				}else{
+				    break;
+				}
 			    }
 			}
 		    } else if ( *(p+1) == '$' ) {
@@ -379,18 +388,33 @@
 			if ( wordcount > 0 ) {
 			    wordnum = wordcount - 1;
 			    slen = strlen( valwords[ wordnum ] );
-			    AC_MEMCPY( f, valwords[ wordnum ], slen );
-			    f += slen;
+			    if( (buflen > slen) && 
+				    ((f - filtbuf) < (buflen - slen)) ){
+				AC_MEMCPY( f, valwords[ i ], slen );
+				f += slen;
+			    }else{
+				break;
+			    }
 			}
 		    } else if ( value != NULL ) {
 			slen = strlen( value );
-			AC_MEMCPY( f, value, slen );
-			f += slen;
+			if( (buflen > slen) && 
+				((f - filtbuf) < (buflen - slen)) ){
+			    AC_MEMCPY( f, valwords[ i ], slen );
+			    f += slen;
+			}else{
+			    break;
+			}
 		    }
 		} else if ( *p == 'a' && attr != NULL ) {
 		    slen = strlen( attr );
-		    AC_MEMCPY( f, attr, slen );
-		    f += slen;
+		    if( (buflen > slen) && 
+			    ((f - filtbuf) < (buflen - slen)) ){
+			AC_MEMCPY( f, valwords[ i ], slen );
+			f += slen;
+		    }else{
+			break;
+		    }
 		} else {
 		    *f++ = *p;
 		}
@@ -405,7 +429,9 @@
 	    }
 	}
 
-	if ( suffix != NULL && ( (size_t) (f - filtbuf) < buflen ) )
+	slen = strlen(suffix);
+	if ( suffix != NULL && ( (size_t) (f - filtbuf) < (buflen - slen)) &&
+		(buflen > slen) )
 	{
 	    strcpy( f, suffix );
 	} else {
--- libraries/libldap/init.c	2002/10/15 10:46:31	1.1
+++ libraries/libldap/init.c	2002/10/30 09:18:02	1.2
@@ -506,6 +506,7 @@
 #endif
 
 	openldap_ldap_init_w_sysconf(LDAP_CONF_FILE);
+	if( getuid() == geteuid() ){
 	openldap_ldap_init_w_userconf(LDAP_USERRC_FILE);
 
 	{
@@ -535,6 +536,7 @@
 	}
 
 	openldap_ldap_init_w_env(gopts, NULL);
+	}
 
 	ldap_int_sasl_init();
 }
--- servers/slurpd/lock.c	2002/08/16 10:50:52	1.1
+++ servers/slurpd/lock.c	2002/10/15 10:42:19
@@ -43,8 +43,7 @@
 	char	buf[MAXPATHLEN];
 
 	/* open the lock file */
-	strcpy( buf, fname );
-	strcat( buf, ".lock" );
+	snprintf(buf,MAXPATHLEN,"%s.lock",fname);
 	if ( (*lfp = fopen( buf, "w" )) == NULL ) {
 		Debug( LDAP_DEBUG_ANY,
 			"Error: could not open \"%s\"\n", buf, 0, 0 );
--- servers/slurpd/sanity.c	2002/08/16 11:18:46	1.1
+++ servers/slurpd/sanity.c	2002/08/16 11:21:54
@@ -180,7 +180,7 @@
     char		*p;
     unsigned int	ret = 0;
 
-    strcpy( dir, f );
+    snprintf( dir, sizeof dir, "%s", f );
     p = strrchr( dir, '/' );
     if ( p != NULL ) {
 	*p = '\0';
--- libraries/libldap/tmplout.c	2002/07/18 09:07:07	1.1
+++ libraries/libldap/tmplout.c	2002/07/18 09:07:50
@@ -9,6 +9,8 @@
  */
 
 #include "portable.h"
+#include <stdarg.h>
+#include <errno.h>
 
 #include <stdio.h>
 
@@ -33,35 +35,49 @@
 
 #define writeptype ldap_writeptype
 
+/* This struct contains all the data required for output */
+struct obuf {
+	writeptype	func;
+	void *		parm;
+	int		error;
+
+	char *		base;
+	unsigned int	ptr, size;
+};
+
 /* local functions */
+static int  obuf_init(LDAP *, struct obuf *, writeptype, void *);
+static int obuf_close(struct obuf *);
+static void obuf_puts(struct obuf *, const char *);
+static void obuf_puts_escaped(struct obuf *, const char *);
+static void obuf_printf(struct obuf *, const char *, ...);
+
 static int do_entry2text LDAP_P((
-	LDAP *ld, char *buf, char *base, LDAPMessage *entry,
+	LDAP *ld, struct obuf *, char *base, LDAPMessage *entry,
 	struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,
-	writeptype writeproc, void *writeparm, char *eol, int rdncount,
+	char *eol, int rdncount,
 	unsigned long opts, char *urlprefix ));
 static int do_entry2text_search LDAP_P((
-	LDAP *ld, char *dn, char *base,
+	LDAP *ld, struct obuf *, char *dn, char *base,
 	LDAPMessage *entry, struct ldap_disptmpl *tmpllist, char **defattrs,
-	char ***defvals, writeptype writeproc, void *writeparm, char *eol,
+	char ***defvals, char *eol,
 	int rdncount, unsigned long opts, char *urlprefix ));
 static int do_vals2text LDAP_P((
-	LDAP *ld, char *buf, char **vals, char *label,
-	int labelwidth, unsigned long syntaxid, writeptype writeproc,
-	void *writeparm, char *eol, int rdncount, char *urlprefix ));
+	LDAP *ld, struct obuf *, char **vals, char *label,
+	int labelwidth, unsigned long syntaxid,
+	char *eol, int rdncount, char *urlprefix ));
 static int max_label_len LDAP_P(( struct ldap_disptmpl *tmpl ));
 static int output_label LDAP_P((
-	char *buf, char *label, int width,
-	writeptype writeproc, void *writeparm, char *eol, int html ));
+	struct obuf *, char *label, int width, char *eol, int html ));
 static int output_dn LDAP_P((
-	char *buf, char *dn, int width, int rdncount,
-	writeptype writeproc, void *writeparm, char *eol, char *urlprefix ));
-static void strcat_escaped LDAP_P(( char *s1, char *s2 ));
+	struct obuf *, char *dn, int width, int rdncount,
+	char *eol, char *urlprefix ));
 static char *time2text LDAP_P(( char *ldtimestr, int dateonly ));
 static long gtime LDAP_P(( struct tm *tm ));
 static int searchaction LDAP_P((
-	LDAP *ld, char *buf, char *base, LDAPMessage *entry,
+	LDAP *ld, struct obuf *, char *base, LDAPMessage *entry,
 	char *dn, struct ldap_tmplitem *tip, int labelwidth, int rdncount,
-	writeptype writeproc, void *writeparm, char *eol, char *urlprefix ));
+	char *eol, char *urlprefix ));
 
 #define DEF_LABEL_WIDTH		15
 #define SEARCH_TIMEOUT_SECS	120
@@ -89,11 +105,18 @@
 	unsigned long		opts
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_entry2text\n", 0, 0, 0 );
 
-    return( do_entry2text( ld, buf, NULL, entry, tmpl, defattrs, defvals,
-		writeproc, writeparm, eol, rdncount, opts, NULL ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+        return ld->ld_errno;
+    res = do_entry2text(ld, &obuf, NULL, entry, tmpl, defattrs, defvals,
+			eol, rdncount, opts, NULL );
+    obuf_close(&obuf);
 
+    return res;
 }
 
 
@@ -115,28 +138,34 @@
 	char			*urlprefix
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_entry2html\n", 0, 0, 0 );
 
     if ( urlprefix == NULL ) {
 	urlprefix = DEF_LDAP_URL_PREFIX;
     }
 
-    return( do_entry2text( ld, buf, base, entry, tmpl, defattrs, defvals,
-		writeproc, writeparm, eol, rdncount, opts, urlprefix ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+        return ld->ld_errno;
+    res = do_entry2text( ld, &obuf, base, entry, tmpl, defattrs, defvals,
+		eol, rdncount, opts, urlprefix );
+    obuf_close(&obuf);
+
+    return res;
 }
 
 
 static int
 do_entry2text(
 	LDAP			*ld,
-	char			*buf,		/* NULL for use-internal */
+	struct obuf		*bp,
 	char			*base,		/* used for search actions */
 	LDAPMessage		*entry,
 	struct ldap_disptmpl	*tmpl,
 	char			**defattrs,
 	char			***defvals,
-	writeptype		writeproc,
-	void			*writeparm,
 	char			*eol,
 	int			rdncount,
 	unsigned long		opts,
@@ -144,7 +173,7 @@
 )
 {
     int				i, err, html, show, labelwidth;
-    int				freebuf,  freevals;
+    int				 freevals;
     char			*dn, **vals;
     struct ldap_tmplitem	*rowp, *colp;
 
@@ -152,17 +181,6 @@
 	return( ld->ld_errno );
     }
 
-    if ( buf == NULL ) {
-	if (( buf = LDAP_MALLOC( LDAP_DTMPL_BUFSIZ )) == NULL ) {
-	    ld->ld_errno = LDAP_NO_MEMORY;
-	    LDAP_FREE( dn );
-	    return( ld->ld_errno );
-	}
-	freebuf = 1;
-    } else {
-	freebuf = 0;
-    }
-
     html = ( urlprefix != NULL );
 
     if ( html ) {
@@ -170,16 +188,15 @@
 	 * add HTML intro. and title
 	 */
 	if (!(( opts & LDAP_DISP_OPT_HTMLBODYONLY ) != 0 )) {
-	    sprintf( buf, "<HTML>%s<HEAD>%s<TITLE>%s%s - ", eol, eol, eol,
+	    obuf_printf(bp,
+	    	    "<HTML>%s<HEAD>%s<TITLE>%s%s - ", eol, eol, eol,
 		    ( tmpl == NULL ) ? "Entry" : tmpl->dt_name );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
-	    output_dn( buf, dn, 0, rdncount, writeproc, writeparm, "", NULL );
-	    sprintf( buf, "%s</TITLE>%s</HEAD>%s<BODY>%s<H3>%s - ", eol, eol,
+	    output_dn( bp, dn, 0, rdncount, "", NULL );
+	    obuf_printf(bp,
+	    	    "%s</TITLE>%s</HEAD>%s<BODY>%s<H3>%s - ", eol, eol,
 		    eol, eol, ( tmpl == NULL ) ? "Entry" : tmpl->dt_name );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
-	    output_dn( buf, dn, 0, rdncount, writeproc, writeparm, "", NULL );
-	    sprintf( buf, "</H3>%s", eol );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
+	    output_dn( bp, dn, 0, rdncount, "", NULL );
+	    obuf_printf(bp, "</H3>%s", eol );
 	}
 
 	if (( opts & LDAP_DISP_OPT_NONLEAF ) != 0 &&
@@ -189,43 +206,42 @@
 	    /*
 	     * add "Move Up" link
 	     */
-	    sprintf( buf, "<A HREF=\"%s", urlprefix );
+	    obuf_printf(bp, "<A HREF=\"%s", urlprefix );
 	    for ( i = 1; vals[ i ] != NULL; ++i ) {
 		if ( i > 1 ) {
-		     strcat_escaped( buf, ", " );
+		     obuf_puts_escaped(bp, ", " );
 		}
-		strcat_escaped( buf, vals[ i ] );
+		obuf_puts_escaped(bp, vals[ i ] );
 	    }
 	    if ( vals[ 1 ] != NULL ) {
 		untagged = strchr( vals[ 1 ], '=' );
 	    } else {
 		untagged = "=The World";
 	    }
-	    sprintf( buf + strlen( buf ),
+	    obuf_printf(bp,
 		    "%s\">Move Up To <EM>%s</EM></A>%s<BR>",
 		    ( vals[ 1 ] == NULL ) ? "??one" : "",
 		    ( untagged != NULL ) ? untagged + 1 : vals[ 1 ], eol );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 
 	    /*
 	     * add "Browse" link
 	     */
 	    untagged = strchr( vals[ 0 ], '=' );
-	    sprintf( buf, "<A HREF=\"%s", urlprefix );
-	    strcat_escaped( buf, dn );
-	    sprintf( buf + strlen( buf ), "??one?(!(objectClass=dsa))\">Browse Below <EM>%s</EM></A>%s%s",
+	    obuf_printf(bp, "<A HREF=\"%s", urlprefix );
+	    obuf_puts_escaped(bp, dn);
+	    obuf_printf(bp,
+	    	    "??one?(!(objectClass=dsa))\">Browse Below <EM>%s</EM>"
+		    "</A>%s%s",
 		    ( untagged != NULL ) ? untagged + 1 : vals[ 0 ], eol, eol );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 
 	    ldap_value_free( vals );
 	}
 
-	(*writeproc)( writeparm, "<HR>", 4 );	/* horizontal rule */
+	obuf_puts(bp, "<HR>");		/* horizontal rule */
     } else {
-	(*writeproc)( writeparm, "\"", 1 );
-	output_dn( buf, dn, 0, rdncount, writeproc, writeparm, "", NULL );
-	sprintf( buf, "\"%s", eol );
-	(*writeproc)( writeparm, buf, strlen( buf ));
+	obuf_puts(bp, "\"");
+	output_dn(bp, dn, 0, rdncount, "", NULL );
+	obuf_printf(bp, "\"%s", eol );
     }
 
     if ( tmpl != NULL && ( opts & LDAP_DISP_OPT_AUTOLABELWIDTH ) != 0 ) {
@@ -262,8 +278,8 @@
 
 	    *attr = TOUPPER( (unsigned char) *attr );
 
-	    err = do_vals2text( ld, buf, vals, attr, labelwidth,
-		    LDAP_SYN_CASEIGNORESTR, writeproc, writeparm, eol, 
+	    err = do_vals2text( ld, bp, vals, attr, labelwidth,
+		    LDAP_SYN_CASEIGNORESTR, eol, 
 		    rdncount, urlprefix );
 	    if ( freevals ) {
 		ldap_value_free( vals );
@@ -321,17 +337,17 @@
 		    if (( opts & LDAP_DISP_OPT_DOSEARCHACTIONS ) != 0 ) {
 			if ( colp->ti_attrname == NULL || ( show &&
 				TOUPPER( (unsigned char) vals[ 0 ][ 0 ] ) == 'T' )) {
-			    err = searchaction( ld, buf, base, entry, dn, colp,
-				    labelwidth, rdncount, writeproc,
-				    writeparm, eol, urlprefix );
+			    err = searchaction( ld, bp, base, entry, dn, colp,
+				    labelwidth, rdncount,
+				    eol, urlprefix );
 			}
 		    }
 		    show = 0;
 		}
 
 		if ( show ) {
-		    err = do_vals2text( ld, buf, vals, colp->ti_label,
-			labelwidth, colp->ti_syntaxid, writeproc, writeparm,
+		    err = do_vals2text( ld, bp, vals, colp->ti_label,
+			labelwidth, colp->ti_syntaxid,
 			eol, rdncount, urlprefix );
 		}
 
@@ -343,15 +359,10 @@
     }
 
     if ( html  && !(( opts & LDAP_DISP_OPT_HTMLBODYONLY ) != 0 )) {
-	sprintf( buf, "</BODY>%s</HTML>%s", eol, eol );
-	(*writeproc)( writeparm, buf, strlen( buf ));
+	obuf_printf(bp, "</BODY>%s</HTML>%s", eol, eol );
     }
 
     LDAP_FREE( dn );
-    if ( freebuf ) {
-	LDAP_FREE( buf );
-    }
-
     return( err );
 }
 
@@ -372,10 +383,19 @@
 	unsigned long		opts
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_entry2text_search\n", 0, 0, 0 );
 
-    return( do_entry2text_search( ld, dn, base, entry, tmpllist, defattrs,
-	    defvals, writeproc, writeparm, eol, rdncount, opts, NULL ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+    	return ld->ld_errno;
+
+    res = do_entry2text_search( ld, &obuf, dn, base, entry, tmpllist, defattrs,
+	    defvals, eol, rdncount, opts, NULL );
+    
+    obuf_close(&obuf);
+    return res;
 }
 
 
@@ -397,24 +417,32 @@
 	char			*urlprefix
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_entry2html_search\n", 0, 0, 0 );
 
-    return( do_entry2text_search( ld, dn, base, entry, tmpllist, defattrs,
-	    defvals, writeproc, writeparm, eol, rdncount, opts, urlprefix ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+    	return ld->ld_errno;
+
+    res = do_entry2text_search( ld, &obuf, dn, base, entry, tmpllist, defattrs,
+	    defvals, eol, rdncount, opts, urlprefix );
+    
+    obuf_close(&obuf);
+    return res;
 }
 
 
 static int
 do_entry2text_search(
 	LDAP			*ld,
+	struct obuf		*bp,
 	char			*dn,		/* if NULL, use entry */
 	char			*base,		/* if NULL, no search actions */
 	LDAPMessage		*entry, 	/* if NULL, use dn */
 	struct ldap_disptmpl*	tmpllist,	/* if NULL, load default file */
 	char			**defattrs,
 	char			***defvals,
-	writeptype		writeproc,
-	void			*writeparm,
 	char			*eol,
 	int			rdncount,	/* if 0, display full DN */
 	unsigned long		opts,
@@ -422,7 +450,7 @@
 )
 {
     int				err, freedn, freetmpls, html;
-    char			*buf, **fetchattrs, **vals;
+    char			**fetchattrs, **vals;
     LDAPMessage			*ldmp;
     struct ldap_disptmpl	*tmpl;
     struct timeval		timeout;
@@ -437,27 +465,20 @@
     timeout.tv_sec = SEARCH_TIMEOUT_SECS;
     timeout.tv_usec = 0;
 
-    if (( buf = LDAP_MALLOC( LDAP_DTMPL_BUFSIZ )) == NULL ) {
-	ld->ld_errno = LDAP_NO_MEMORY;
-	return( ld->ld_errno );
-    }
-
     freedn = freetmpls = 0;
     tmpl = NULL;
 
     if ( tmpllist == NULL ) {
 	if (( err = ldap_init_templates( TEMPLATEFILE, &tmpllist )) != 0 ) {
-	    sprintf( buf, "%sUnable to read template file %s (error %d)%s%s",
+	    obuf_printf(bp, "%sUnable to read template file %s (error %d)%s%s",
 		    html ? "<!-- " : "", TEMPLATEFILE, err,
 		    html ? "-->" : "", eol );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 	}
 	freetmpls = 1;
     }
 
     if ( dn == NULL ) {
 	if (( dn = ldap_get_dn( ld, entry )) == NULL ) {
-	    LDAP_FREE( buf );
 	    if ( freetmpls ) {
 		ldap_free_templates( tmpllist );
 	    }
@@ -518,14 +539,12 @@
 	if ( freetmpls ) {
             ldap_free_templates( tmpllist );
         }
-	LDAP_FREE( buf );
 	return( ld->ld_errno );
     }
 
-    err = do_entry2text( ld, buf, base, entry, tmpl, defattrs, defvals,
-	    writeproc, writeparm, eol, rdncount, opts, urlprefix );
+    err = do_entry2text( ld, bp, base, entry, tmpl, defattrs, defvals,
+	    eol, rdncount, opts, urlprefix );
 
-    LDAP_FREE( buf );
     if ( freetmpls ) {
 	ldap_free_templates( tmpllist );
     }
@@ -548,10 +567,19 @@
 	int			rdncount
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_vals2text\n", 0, 0, 0 );
 
-    return( do_vals2text( ld, buf, vals, label, labelwidth, syntaxid,
-		writeproc, writeparm, eol, rdncount, NULL ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+    	return ld->ld_errno;
+
+    res = do_vals2text( ld, &obuf, vals, label, labelwidth, syntaxid,
+		eol, rdncount, NULL );
+
+    obuf_close(&obuf);
+    return res;
 }
 
 
@@ -570,33 +598,40 @@
 	char			*urlprefix
 )
 {
+    struct obuf	obuf;
+    int		res;
+
     Debug( LDAP_DEBUG_TRACE, "ldap_vals2html\n", 0, 0, 0 );
 
     if ( urlprefix == NULL ) {
 	urlprefix = DEF_LDAP_URL_PREFIX;
     }
 
-    return( do_vals2text( ld, buf, vals, label, labelwidth, syntaxid,
-		writeproc, writeparm, eol, rdncount, urlprefix ));
+    if (!obuf_init(ld, &obuf, writeproc, writeparm))
+    	return ld->ld_errno;
+
+    res = do_vals2text( ld, &obuf, vals, label, labelwidth, syntaxid,
+			eol, rdncount, urlprefix );
+
+    obuf_close(&obuf);
+    return res;
 }
 
 
 static int
 do_vals2text(
 	LDAP			*ld,
-	char			*buf,		/* NULL for "use internal" */
+	struct obuf		*bp,
 	char			**vals,
 	char			*label,
 	int			labelwidth,	/* 0 means use default */
 	unsigned long		syntaxid,
-	writeptype		writeproc,
-	void			*writeparm,
 	char			*eol,
 	int			rdncount,
 	char			*urlprefix
 )
 {
-    int		i, html, writeoutval, freebuf, notascii;
+    int		i, html, writeoutval, notascii;
     char	*p, *s, *outval;
 
 
@@ -618,17 +653,7 @@
 	labelwidth = DEF_LABEL_WIDTH;
     }
 
-    if ( buf == NULL ) {
-	if (( buf = LDAP_MALLOC( LDAP_DTMPL_BUFSIZ )) == NULL ) {
-	    ld->ld_errno = LDAP_NO_MEMORY;
-	    return( ld->ld_errno );
-	}
-	freebuf = 1;
-    } else {
-	freebuf = 0;
-    }
-
-    output_label( buf, label, labelwidth, writeproc, writeparm, eol, html );
+    output_label( bp, label, labelwidth, eol, html );
 
     for ( i = 0; vals[ i ] != NULL; ++i ) {
 	for ( p = vals[ i ]; *p != '\0'; ++p ) {
@@ -649,24 +674,22 @@
 
 	case LDAP_SYN_RFC822ADDR:
 	    if ( html ) {
-		strcpy( buf, "<DD><A HREF=\"mailto:" );
-		strcat_escaped( buf, outval );
-		sprintf( buf + strlen( buf ), "\">%s</A><BR>%s", outval, eol );
-		(*writeproc)( writeparm, buf, strlen( buf ));
+		obuf_printf(bp, "<DD><A HREF=\"mailto:" );
+		obuf_puts_escaped(bp, outval );
+		obuf_printf(bp, "\">%s</A><BR>%s", outval, eol );
 	    } else {
 		++writeoutval;
 	    }
 	    break;
 
 	case LDAP_SYN_DN:	/* for now */
-	    output_dn( buf, outval, labelwidth, rdncount, writeproc,
-		    writeparm, eol, urlprefix );
+	    output_dn( bp, outval, labelwidth, rdncount,
+		    eol, urlprefix );
 	    break;
 
 	case LDAP_SYN_MULTILINESTR:
 	    if ( i > 0 && !html ) {
-		output_label( buf, label, labelwidth, writeproc,
-			writeparm, eol, html );
+		output_label( bp, label, labelwidth, eol, html );
 	    }
 
 	    p = s = outval;
@@ -676,11 +699,10 @@
 		    ++s;
 		}
 		if ( html ) {
-		    sprintf( buf, "<DD>%s<BR>%s", p, eol );
+		    obuf_printf( bp, "<DD>%s<BR>%s", p, eol );
 		} else {
-		    sprintf( buf, "%-*s%s%s", labelwidth, " ", p, eol );
+		    obuf_printf( bp, "%-*s%s%s", labelwidth, " ", p, eol );
 		}
-		(*writeproc)( writeparm, buf, strlen( buf ));
 		p = s;
 	    }
 	    outval = p;
@@ -720,34 +742,27 @@
 	     * at this point `s' points to the label & `p' to the URL
 	     */
 	    if ( html ) {
-		sprintf( buf, "<DD><A HREF=\"%s\">%s</A><BR>%s", p, s, eol );
+		obuf_printf( bp, "<DD><A HREF=\"%s\">%s</A><BR>%s", p, s, eol );
 	    } else {
-		sprintf( buf, "%-*s%s%s%-*s%s%s", labelwidth, " ",
+		obuf_printf( bp, "%-*s%s%s%-*s%s%s", labelwidth, " ",
 		    s, eol, labelwidth + 2, " ",p , eol );
 	    }
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 	    break;
 
 	default:
-	    sprintf( buf, " Can't display item type %ld%s",
+	    obuf_printf( bp, " Can't display item type %ld%s",
 		    syntaxid, eol );
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 	}
 
 	if ( writeoutval ) {
 	    if ( html ) {
-		sprintf( buf, "<DD>%s<BR>%s", outval, eol );
+		obuf_printf( bp, "<DD>%s<BR>%s", outval, eol );
 	    } else {
-		sprintf( buf, "%-*s%s%s", labelwidth, " ", outval, eol );
+		obuf_printf( bp, "%-*s%s%s", labelwidth, " ", outval, eol );
 	    }
-	    (*writeproc)( writeparm, buf, strlen( buf ));
 	}
     }
 
-    if ( freebuf ) {
-	LDAP_FREE( buf );
-    }
-
     return( LDAP_SUCCESS );
 }
 
@@ -775,32 +790,27 @@
 
 
 static int
-output_label( char *buf, char *label, int width, writeptype writeproc,
-	void *writeparm, char *eol, int html )
+output_label( struct obuf *bp, char *label, int width,
+	char *eol, int html )
 {
-    char	*p;
+    unsigned int	len;
 
     if ( html ) {
-	sprintf( buf, "<DT><B>%s</B>", label );
+	obuf_printf( bp, "<DT><B>%s</B>", label );
     } else {
-	sprintf( buf, " %s:", label );
-	p = buf + strlen( buf );
-
-	while ( p - buf < width ) {
-	    *p++ = ' ';
-	}
+	obuf_printf( bp, " %s:", label );
 
-	*p = '\0';
-	strcat( buf, eol );
+	len = strlen(label) + 2;
+	if (len < width)
+	    obuf_printf( bp, "%-*s", width-len, " " );
+	obuf_puts(bp, eol );
     }
-
-    return ((*writeproc)( writeparm, buf, strlen( buf )));
 }
 
 
 static int
-output_dn( char *buf, char *dn, int width, int rdncount,
-	writeptype writeproc, void *writeparm, char *eol, char *urlprefix )
+output_dn( struct obuf *bp, char *dn, int width, int rdncount,
+	char *eol, char *urlprefix )
 {
     char	**dnrdns;
     int		i;
@@ -810,32 +820,29 @@
     }
 
     if ( urlprefix != NULL ) {
-	sprintf( buf, "<DD><A HREF=\"%s", urlprefix );
-	strcat_escaped( buf, dn );
-	strcat( buf, "\">" );
+	obuf_printf( bp, "<DD><A HREF=\"%s", urlprefix );
+	obuf_puts_escaped(bp, dn );
+	obuf_puts( bp, "\">" );
     } else if ( width > 0 ) {
-	sprintf( buf, "%-*s", width, " " );
-    } else {
-	*buf = '\0';
+	obuf_printf( bp, "%-*s", width, " " );
     }
 
     for ( i = 0; dnrdns[ i ] != NULL && ( rdncount == 0 || i < rdncount );
 	    ++i ) {
 	if ( i > 0 ) {
-	    strcat( buf, ", " );
+	    obuf_puts( bp, ", " );
 	}
-	strcat( buf, dnrdns[ i ] );
+	obuf_puts( bp, dnrdns[ i ] );
     }
 
     if ( urlprefix != NULL ) {
-	strcat( buf, "</A><BR>" );
+	obuf_puts( bp, "</A><BR>" );
     }
 
     ldap_value_free( dnrdns );
 
-    strcat( buf, eol );
-
-    return ((*writeproc)( writeparm, buf, strlen( buf )));
+    obuf_puts( bp, eol );
+    return 0;
 }
 
 
@@ -1000,9 +1007,9 @@
 }
 
 static int
-searchaction( LDAP *ld, char *buf, char *base, LDAPMessage *entry, char *dn,
-	struct ldap_tmplitem *tip, int labelwidth, int rdncount,
-	writeptype writeproc, void *writeparm, char *eol, char *urlprefix )
+searchaction( LDAP *ld, struct obuf *bp, char *base, LDAPMessage *entry,
+	char *dn, struct ldap_tmplitem *tip, int labelwidth, int rdncount,
+	char *eol, char *urlprefix )
 {
     int			err = 0, lderr, i, count, html;
     char		**vals, **members;
@@ -1049,17 +1056,14 @@
 	 * search action as an LDAP URL, instead of actually doing the search
 	 * now.
 	 */
-	sprintf( buf, "<DT><A HREF=\"%s", urlprefix );
+	obuf_printf( bp, "<DT><A HREF=\"%s", urlprefix );
 	if ( base != NULL ) {
-	    strcat_escaped( buf, base );
+	    obuf_puts_escaped(bp, base );
 	}
-	strcat( buf, "??sub?" );
-	strcat_escaped( buf, filter );
-	sprintf( buf + strlen( buf ), "\"><B>%s</B></A><DD><BR>%s",
+	obuf_puts_escaped(bp, "??sub?" );
+	obuf_puts_escaped(bp, filter );
+	obuf_printf(bp, "\"><B>%s</B></A><DD><BR>%s",
 		tip->ti_label, eol );
-	if ((*writeproc)( writeparm, buf, strlen( buf )) < 0 ) {
-	    return( LDAP_LOCAL_ERROR );
-	}
 	return( LDAP_SUCCESS );
     }
 
@@ -1084,8 +1088,8 @@
 
 		ldap_sort_values( ld, members, ldap_sort_strcasecmp );
 
-		err = do_vals2text( ld, NULL, members, tip->ti_label,
-			html ? -1 : 0, LDAP_SYN_DN, writeproc, writeparm,
+		err = do_vals2text( ld, bp, members, tip->ti_label,
+			html ? -1 : 0, LDAP_SYN_DN, 
 			eol, rdncount, urlprefix );
 
 		ldap_value_free( members );
@@ -1101,3 +1105,102 @@
 
     return(( err == LDAP_SUCCESS ) ? lderr : err );
 }
+
+/*
+ * All the obuf stuff
+ * No big need to be efficient here...
+ */
+int
+obuf_init(LDAP *ld, struct obuf *bp, writeptype func, void *parm)
+{
+    memset(bp, 0, sizeof(*bp));
+    bp->func = func;
+    bp->parm = parm;
+
+    bp->size = LDAP_DTMPL_BUFSIZ;
+    bp->base = (char *) LDAP_MALLOC(bp->size+1);
+    if (bp->base == NULL) {
+        ld->ld_errno = LDAP_NO_MEMORY;
+        return 0;
+    }
+    return 1;
+}
+
+void
+obuf_printf(struct obuf *bp, const char *fmt, ...)
+{
+    char	buffer[1024];
+    va_list	ap;
+
+    va_start(ap, fmt);
+    vsnprintf(buffer, sizeof(buffer), fmt, ap);
+    va_end(ap);
+
+    obuf_puts(bp, buffer);
+}
+
+static void
+obuf_flush(struct obuf *bp)
+{
+    if (bp->ptr && !bp->error) {
+    	if (bp->func(bp->parm, bp->base, bp->ptr) < 0) {
+	    /* Save the error for later if we haven't done so */
+	    if (bp->error == 0)
+	    	bp->error = errno;
+	}
+    }
+    bp->base[0] = '\0';
+    bp->ptr = 0;
+}
+
+static inline void
+obuf_putc(struct obuf *bp, char c)
+{
+    if (bp->ptr >= bp->size)
+        obuf_flush(bp);
+    bp->base[bp->ptr++] = c;
+}
+
+void
+obuf_puts(struct obuf *bp, const char *s)
+{
+    while (*s)
+        obuf_putc(bp, *s++);
+    obuf_flush(bp);
+}
+
+#define HREF_CHAR_ACCEPTABLE( c )	(( (c) >= '-' && (c) <= '9' ) || \
+					 ( (c) >= '@' && (c) <= 'Z' ) || \
+					 ( (c) == '_' )               || \
+					 ( (c) >= 'a' && (c) <= 'z' ))
+
+void
+obuf_puts_escaped(struct obuf *bp, const char *s)
+{
+    static const char *hexdig = "0123456789ABCDEF";
+
+    while (*s) {
+	if (HREF_CHAR_ACCEPTABLE(*s))
+            obuf_putc(bp, *s++);
+	else {
+            obuf_putc(bp, '%');
+            obuf_putc(bp, hexdig[(*s >> 4) & 0xF]);
+            obuf_putc(bp, hexdig[*s++ & 0xF]);
+	}
+    }
+    obuf_flush(bp);
+}
+
+int
+obuf_close(struct obuf *bp)
+{
+    int	res = 0;
+
+    LDAP_FREE(bp->base);
+    if (bp->error) {
+    	errno = bp->error;
+	res = -1;
+    }
+    memset(bp, 0, sizeof(*bp));
+    return res;
+}
